#include "Server.hpp"
#include <iostream>     // Для вывода в консоль
#include <cstring>      // Для memset
#include <unistd.h>     // Для системных вызовов, таких как close
#include <fcntl.h>      // Для работы с флагами файловых дескрипторов
#include <cerrno>       // Для использования errno и констант ошибок, таких как EWOULDBLOCK

// Конструктор класса Server
// Инициализирует сервер с указанным портом и паролем
Server::Server(int port, const std::string &password) 
    : port(port), password(password) {
    initSocket(); // Настраиваем сокет
}

// Деструктор класса Server
// Закрывает серверный сокет при завершении работы
Server::~Server() {
    close(serverSocket); // Закрываем файловый дескриптор сервера
}

// Метод для настройки серверного сокета
void Server::initSocket() {
    // Создаем сокет
    serverSocket = socket(AF_INET, SOCK_STREAM, 0);
    if (serverSocket < 0) { // Если сокет не создан, выбрасываем исключение
        throw std::runtime_error("Failed to create socket");
    }

    // Переводим сокет в неблокирующий режим
    int flags = fcntl(serverSocket, F_GETFL, 0); // Получаем текущие флаги сокета
    if (flags < 0 || fcntl(serverSocket, F_SETFL, flags | O_NONBLOCK) < 0) { // Добавляем O_NONBLOCK
        throw std::runtime_error("Failed to set non-blocking mode");
    }

    // Указываем настройки адреса сервера
    serverAddr.sin_family = AF_INET;               // Используем IPv4
    serverAddr.sin_addr.s_addr = INADDR_ANY;       // Любой адрес на локальной машине
    serverAddr.sin_port = htons(port);             // Преобразуем порт в сетевой порядок байтов

    // Привязываем сокет к указанному адресу и порту
    if (bind(serverSocket, (struct sockaddr *)&serverAddr, sizeof(serverAddr)) < 0) {
        throw std::runtime_error("Bind failed");
    }

    // Переводим сокет в режим прослушивания
    if (listen(serverSocket, 10) < 0) { // 10 - максимальная очередь подключений
        throw std::runtime_error("Listen failed");
    }

    // Уведомляем, что сервер запущен
    std::cout << "Server started on port " << port << std::endl;
}

// Метод для обработки нового подключения
void Server::acceptConnection() {
    // Принимаем новое соединение
    int clientFd = accept(serverSocket, NULL, NULL); // Возвращает файловый дескриптор клиента
    if (clientFd < 0) { // Если ошибка
        if (errno != EWOULDBLOCK) { // Игнорируем EWOULDBLOCK, так как это ожидаемое поведение
            std::cerr << "Accept error" << std::endl;
        }
        return; // Возвращаемся, чтобы не добавлять клиента
    }

    // Добавляем нового клиента в список для poll()
    struct pollfd clientPoll;
    clientPoll.fd = clientFd;    // Дескриптор нового клиента
    clientPoll.events = POLLIN; // Ожидаем события POLLIN (данные для чтения)
    clients.push_back(clientPoll); // Добавляем клиента в список

    // Уведомляем о новом подключении
    std::cout << "New client connected: " << clientFd << std::endl;
}

// Метод для обработки данных от клиента
void Server::handleClient(int clientFd) {
    char buffer[1024];                          // Буфер для чтения данных
    memset(buffer, 0, sizeof(buffer));          // Очищаем буфер
    ssize_t bytesRead = recv(clientFd, buffer, sizeof(buffer) - 1, 0); // Читаем данные

    if (bytesRead <= 0) { // Если данные не прочитаны или соединение закрыто
        if (bytesRead < 0 && errno != EWOULDBLOCK) { // Игнорируем EWOULDBLOCK
            std::cerr << "Recv error for client " << clientFd << std::endl;
        }
        close(clientFd); // Закрываем соединение
        return;
    }

    // Выводим полученные данные
    std::cout << "Received from client " << clientFd << ": " << buffer << std::endl;

    // Отправляем данные обратно клиенту (эхо-сообщение)
    send(clientFd, buffer, bytesRead, 0);
}

// Главный цикл работы сервера
void Server::run() {
    struct pollfd serverPoll;
    serverPoll.fd = serverSocket; // Добавляем серверный сокет в список для poll()
    serverPoll.events = POLLIN;  // Ожидаем события POLLIN (новое подключение)

    clients.push_back(serverPoll); // Добавляем серверный сокет в список

    while (true) { // Бесконечный цикл обработки событий
        int pollCount = poll(clients.data(), clients.size(), -1); // Ждем событий
        if (pollCount < 0) { // Если ошибка
            throw std::runtime_error("Poll failed");
        }

        for (size_t i = 0; i < clients.size(); ++i) { // Проходим по всем дескрипторам
            if (clients[i].revents & POLLIN) { // Если событие POLLIN
                if (clients[i].fd == serverSocket) { // Если это серверный сокет
                    acceptConnection(); // Обрабатываем новое подключение
                } else { // Если это клиентский сокет
                    handleClient(clients[i].fd); // Обрабатываем данные от клиента
                }
            }
        }
    }
}
